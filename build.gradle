import com.github.jk1.license.render.*
import com.github.jk1.license.importer.*

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        gradlePluginPortal()
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath "com.github.alisiikh:gradle-scalastyle-plugin:3.5.0"
        classpath 'com.commercehub.gradle.plugin:gradle-avro-plugin:0.16.0'
        classpath 'com.adtran:scala-multiversion-plugin:2.0.4'
    }
}

plugins {
    id 'org.scoverage' version '8.0.3'
    id 'org.cadixdev.licenser' version '0.6.1'
    id 'com.github.jk1.dependency-license-report' version '2.5'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
}

allprojects {
    repositories {
        mavenLocal()
        mavenCentral()
        gradlePluginPortal()
    }
}

apply from: 'gradle/version-properties.gradle'

def allProjs = allprojects - project(':templates').subprojects
def subProjs = subprojects - project(':templates').subprojects

// distribute to all projects
ext.subProjs = subProjs

configure(allProjs) {
    apply plugin: 'application'
    apply plugin: 'java-library'
    apply plugin: 'scala'
    // apply plugin: 'findbugs'
    apply plugin: 'org.scoverage'
    apply plugin: "com.github.alisiikh.scalastyle"
    apply plugin: 'maven-publish'
    apply plugin: 'signing'
    apply plugin: 'project-report'
    apply plugin: 'com.commercehub.gradle.plugin.avro'
    apply plugin: 'org.cadixdev.licenser'
    apply plugin: 'com.github.jk1.dependency-license-report'
    apply plugin: 'com.github.johnrengelman.shadow'
    apply plugin: 'com.adtran.scala-multiversion-plugin'

    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11

    // The main class for the application plugin and is currently unused. Setting a dummy one.
    application {
        mainClass.set("please.set.main.class.in.build.gradle")
    }

    ext {
        scalaTestVersion = '3.0.9'
        scalaCheckVersion = '1.17.0'
        junitVersion = '4.13.2'
        avroVersion = '1.11.1'
        sparkVersion = '3.4.2'
        scalaGraphVersion = '1.13.1'
        scalafmtVersion = '1.5.1'
        hadoopVersion = 'hadoop2'
        json4sVersion = '3.7.0-M11' // matches Spark dependency version
        jodaTimeVersion = '2.12.5'
        algebirdVersion = '0.13.10'
        jacksonVersion = '2.14.2'
        luceneVersion = '7.3.0'
        enumeratumVersion = '1.4.18'
        scoptVersion = '3.7.1'
        googleLibPhoneNumberVersion = '8.12.0'
        chillVersion = '0.9.3'
        reflectionsVersion = '0.10.2'
        collectionsVersion = '3.2.2'
        optimaizeLangDetectorVersion = '0.0.1'
        tikaVersion = '2.4.1'
        sparkTestingBaseVersion = '3.4.2_1.5.2'
        sourceCodeVersion = '0.3.0'
        commonsValidatorVersion = '1.7'
        commonsIOVersion = '2.13.0'
        scoveragePluginVersion = '2.0.8'
        xgboostVersion = '1.5.2'
        akkaSlf4jVersion = '2.5.23'
        mleapVersion = '0.23.0'
        memoryFilesystemVersion = '2.1.0'
    }

    configurations {
        scalaLibrary
        scalaCompiler
    }

    dependencies {
        scalaLibrary "org.scala-lang:scala-library:$scalaVersion"
        scalaCompiler "org.scala-lang:scala-compiler:$scalaVersion"
        implementation "org.scala-lang:scala-library:$scalaVersion"

        // Spark
        compileOnly "org.apache.spark:spark-core_%%:$sparkVersion"
        testImplementation "org.apache.spark:spark-core_%%:$sparkVersion"
        compileOnly "org.apache.spark:spark-mllib_%%:$sparkVersion"
        testImplementation "org.apache.spark:spark-mllib_%%:$sparkVersion"
        compileOnly "org.apache.spark:spark-sql_%%:$sparkVersion"
        testImplementation "org.apache.spark:spark-sql_%%:$sparkVersion"

        // Test
        compileOnly "org.scalatest:scalatest_%%:$scalaTestVersion"
        testImplementation "org.scalatest:scalatest_%%:$scalaTestVersion"
        compileOnly "org.scalacheck:scalacheck_%%:$scalaCheckVersion"
        testImplementation "org.scalacheck:scalacheck_%%:$scalaCheckVersion"
        testImplementation ("com.holdenkarau:spark-testing-base_%%:$sparkTestingBaseVersion") { transitive = false }
        testImplementation "junit:junit:$junitVersion"
    }
    
    configurations.all {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.group == 'ml.dmlc') {
                details.useVersion "$xgboostVersion"
            }
        }
    }

    configurations.all {
        resolutionStrategy {
            force "commons-collections:commons-collections:$collectionsVersion",
                    "org.scala-lang:scala-library:$scalaVersion",
                    "org.scala-lang:scala-reflect:$scalaVersion"
        }
    }
    configurations.zinc {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.group == 'org.scala-lang') {
                details.useVersion '2.13.11'
            }
        }
    }

    tasks.withType(ScalaCompile) {
        configure(scalaCompileOptions.forkOptions) {
            memoryMaximumSize = '1g'
            jvmArgs = ['-XX:MaxMetaspaceSize=256m']
        }
        scalaCompileOptions.additionalParameters = [
                "-Yrangepos", "-feature",
                "-language:implicitConversions", "-language:existentials", "-language:postfixOps",
                "-opt:l:inline", "-opt-inline-from:**"
        ]
    }
    [compileJava, compileTestJava]*.options.collect { options -> options.encoding = 'UTF-8' }

    jar {
        manifest.attributes "Main-Class": "$mainClassName"
        archiveBaseName = "$rootProject.name"
    }
    if (System.getenv("CI") != 'true') {
        jar.dependsOn(createVersionProperties)
    }

    scalastyle {
        scalaVersion = '%%'
        scalastyleVersion = '1.5.1'
        config = file("$rootProject.rootDir/gradle/scalastyle-config.xml")
    }

    if (System.getenv("CI") != 'true') {
        compileScala.dependsOn(scalastyleCheck)
    }

    avro {
        createSetters = true
        fieldVisibility = "PUBLIC_DEPRECATED"
        outputCharacterEncoding = "UTF-8"
        stringType = "String"
    }

    sourceSets {
        main {
            java {
                srcDir 'build/generated-main-avro-java'
            }
        }
        scoverage {
            runtimeClasspath += sourceSets.main.output
            compileClasspath += sourceSets.main.output
        }
        testScoverage {
            runtimeClasspath += sourceSets.main.output + sourceSets.test.output
            compileClasspath += sourceSets.main.output + sourceSets.test.output
        }
    }

    license {
        header = rootProject.file('LICENSE')
        ignoreFailures = true
        include '**/*.java', '**/*.scala'
        exclude '**/org/apache/spark/ml/SparkDefaultParamsReadWrite.scala',
                '**/com/salesforce/op/test/TestSparkContext.scala',
                '**/com/salesforce/op/test/TempDirectoryTest.scala',
                '**/com/salesforce/op/stages/impl/tuning/OpCrossValidation.scala',
                '**/com/salesforce/op/stages/impl/tuning/OpTrainValidationSplit.scala',
                '**/com/salesforce/op/test/*.java',
                '**/com/fasterxml/jackson/module/scala/**',
                '**/com/salesforce/op/utils/stats/StreamingHistogram.java',
                '**/com/salesforce/app/schema/PassengerDataAll.java',
                '**/templates/**', '**/resources/**'
    }
    scoverage {
        coverageOutputCobertura = false
        scoverageVersion = scoveragePluginVersion
    }

    licenseReport {
        renderers = [new CsvReportRenderer(), new InventoryHtmlReportRenderer()]
    }

    shadowJar {
        zip64 = true
        exclude 'META-INF/**'
        archiveBaseName = jar.baseName

        // Concatenate modularized mleap metadata
        // https://github.com/combust/mleap/issues/656
        append 'reference.conf'
    }
    shadowJar.dependsOn(createVersionProperties)

    /* findbugs {
        toolVersion = '3.0.1'
        sourceSets = [sourceSets.main]
        ignoreFailures = true
        reportsDir = file("$project.buildDir/reports/findbugs")
        effort = 'max'
        reportLevel = 'low'
        includeFilter = file("$rootProject.projectDir/gradle/findbugs-include.xml")
        excludeFilter = file("$rootProject.projectDir/gradle/findbugs-exclude.xml")
    } */

    task runMain(type: JavaExec) {
        description 'Run a main class, i.e.: runMain -Dmain=MyMainClass -Dargs="arg1 arg2 arg3"'
        mainClass = System.getProperty("main")
        classpath = sourceSets.main.runtimeClasspath
        systemProperties = System.getProperties()
        args = System.getProperty("args", "") == "" ? new LinkedList<String>() : Arrays.asList(System.getProperty("args").split(" "))
    }

    task repl(type: JavaExec) {
        description 'Start Scala repl.'
        mainClass = "scala.tools.nsc.MainGenericRunner"
        classpath = sourceSets.main.runtimeClasspath + configurations.scalaCompiler
        standardInput System.in
        args '-usejavacp'
    }

    task classpath {
        doLast {
            description 'Print project classpath.'
            println sourceSets.main.runtimeClasspath.asPath
        }
    }

    if (System.getenv("TEST_FILES") != null) {
        testScoverage.setIncludes(Arrays.asList(System.getenv("TEST_FILES").split('\n')))
    }

    afterEvaluate {
        compileScoverageJava.enabled = false
        tasks.withType(com.github.alisiikh.scalastyle.ScalastyleCheckTask) {
            if(it.name.contains("Scoverage")) {
                it.enabled = false
            }
        }
        tasks.withType(GenerateModuleMetadata) {
            enabled = false
        }
    }
}

wrapper {
    gradleVersion = '7.5.1'
    distributionType = Wrapper.DistributionType.BIN
    distributionSha256Sum = 'f6b8596b10cce501591e92f229816aa4046424f3b24d771751b06779d58c8ec4'
}

configure(subProjs) {
    apply from: "$rootProject.projectDir/gradle/tests.gradle"
    apply from: "$rootProject.projectDir/gradle/spark.gradle"

    jar.baseName = "$rootProject.name-$project.name"

    // ignore link warning in scaladoc
    scaladoc.scalaDocOptions.additionalParameters = ['-no-link-warnings']

    task scaladocJar(type: Jar, dependsOn: scaladoc) {
        classifier = 'javadoc'
        from scaladoc.destinationDir
    }
    scaladocJar.baseName = jar.baseName

    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        duplicatesStrategy = 'include'
        from sourceSets.main.allSource
    }
    sourcesJar.baseName = jar.baseName

    artifacts {
        archives jar, sourcesJar, scaladocJar
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                from components.java
                artifact sourcesJar { classifier 'sources' }
                artifact scaladocJar { classifier 'javadoc' }
                afterEvaluate {
                    artifactId = "${jar.baseName}"
                }
                pom {
                    name = 'TransmogrifAI'
                    description = 'AutoML library for building modular, reusable, strongly typed machine learning workflows on Spark with minimal hand tuning'
                    url = 'https://github.com/salesforce/TransmogrifAI'
                    scm {
                        connection = 'scm:git:https://github.com/salesforce/TransmogrifAI.git'
                        developerConnection = 'scm:git:https://github.com/salesforce/TransmogrifAI.git'
                        url = 'https://github.com/salesforce/TransmogrifAI'
                    }
                    licenses {
                        license {
                            name = 'BSD-3-Clause'
                            url = 'https://github.com/salesforce/TransmogrifAI/blob/master/LICENSE'
                            distribution = 'repo'
                        }
                    }
                    developers {
                        developer {
                            id = 'tovbinm'
                            name = 'Matthew Tovbin'
                            email = 'tovbinm@gmail.com'
                        }
                        developer {
                            id = 'leahmcguire'
                            name = 'Leah McGuire'
                            email = 'lmcguire@salesforce.com'
                        }
                    }
                }
            }
        }
        repositories {
            // Disable Sonatype publication for now
            // maven {
            //     // Note: requires 'nexusUsername' and 'nexusPassword' to be set in ~/.gradle/gradle.properties file
            //     url "https://oss.sonatype.org/service/local/staging/deploy/maven2"
            //     credentials {
            //         username nexusUsername
            //         password nexusPassword
            //     }
            // }
            // Disable Bintray publication for now
            // maven {
            //     // Note: requires 'bintrayUsername' and 'bintrayPassword' to be set in ~/.gradle/gradle.properties file
            //     url "https://api.bintray.com/maven/salesforce/maven/TransmogrifAI/;publish=1"
            //     credentials {
            //         username bintrayUsername
            //         password bintrayPassword
            //     }
            // }
            mavenLocal()
        }
    }

    if (System.getenv("SIGN_RELEASE") == 'true') {
        signing {
            // For signing to work read - https://docs.gradle.org/current/userguide/signing_plugin.html
            // Most importantly:
            // 1. Install & configure GPGTools - https://gpgtools.org
            // 2. Copy the full 40 character key id from the output of the command: gpg2 -K
            // 3. Set 'signing.gnupg.keyName=<key id>' in ~/.gradle/gradle.properties file
            // 4. If you protect your key with a passphrase add 'signing.password=<secret>' in ~/.gradle/gradle.properties file
            useGpgCmd()
            sign publishing.publications.mavenJava
        }
    }
}

task allScaladoc(type: ScalaDoc) {
    group 'Documentation'
    description 'Generates Scaladoc for the main source code of all subprojects.'
    title 'TransmogrifAI'
    source subProjs.collect { it.sourceSets.main.allJava + it.sourceSets.main.allScala }
    classpath = files(subProjs.collect { it.sourceSets.main.compileClasspath })
    destinationDir = file("build/scaladoc")
}

// run by Heroku to build docs
task stage(dependsOn: ':allScaladoc')
